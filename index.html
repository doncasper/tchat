<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Twitch Chat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: transparent;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        .chat-container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            border-radius: 8px;
            overflow: hidden;
        }

        .chat-header {
            background: linear-gradient(90deg, #9146ff, #bf46ff);
            padding: 8px 16px;
            color: white;
            font-weight: 600;
            font-size: 0.875em;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .config-button {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 4px;
            padding: 6px;
            cursor: pointer;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .config-button:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .config-icon {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        .chat-messages {
            flex: 1;
            padding: 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 6px;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        .chat-messages::-webkit-scrollbar {
            display: none;
        }

        .message {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0px;
            border-left: 2px dotted #b6b6b6;
            animation: slideIn 0.3s ease;
            color: white;
            font-size: 0.81em;
            line-height: 1.3;
        }

        .message.subscriber {
            border-left-color: #9146ff;
            background: rgba(255, 107, 107, 0.15);
        }

        .message.moderator {
            border-left-color: #00ff00;
            background: rgba(0, 255, 0, 0.15);
        }

        .username {
            font-weight: 600;
            margin-right: 8px;
        }

        .message-text {
            color: rgba(255, 255, 255, 0.9);
        }

        .emote {
            height: 2em;
            width: auto;
            vertical-align: middle;
            margin: 0 1px;
            display: inline-block;
        }

        .badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.625em;
            font-weight: bold;
            margin-right: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
        }

        .badge:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .badge.subscriber {
            background: linear-gradient(135deg, #9146ff, #bf46ff);
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .badge.moderator {
            background: linear-gradient(135deg, #00ff00, #00cc00);
            color: black;
            font-weight: 700;
        }

        .badge.vip {
            background: linear-gradient(135deg, #ffd700, #ffb700);
            color: black;
            font-weight: 700;
        }

        .badge.broadcaster {
            background: linear-gradient(135deg, #ff0000, #cc0000);
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .badge.founder {
            background: linear-gradient(135deg, #ff00d0, #cc00a0);
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .badge.staff {
            background: linear-gradient(135deg, #ff0000, #cc0000);
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .badge.admin {
            background: linear-gradient(135deg, #ff0000, #cc0000);
            color: white;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .badge.global_mod {
            background: linear-gradient(135deg, #00ff00, #00cc00);
            color: black;
            font-weight: 700;
        }

        .badge.premium {
            background: linear-gradient(135deg, #ffd700, #ffb700);
            color: black;
            font-weight: 700;
        }

        .status {
            font-size: 0.75em;
            opacity: 0.8;
        }

        .username-bubble {
            display: inline-block;
            padding: 2px 10px;
            border-radius: 16px;
            font-weight: 600;
            color: #fff !important;
            background: linear-gradient(90deg, #9146ff, #bf46ff);
            margin-right: 8px;
            box-shadow: 0 1px 4px 0 rgba(0,0,0,0.10);
            font-size: 0.81em;
            letter-spacing: 0.01em;
            transition: background 0.2s;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 24px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            transform: translateY(-20px);
            transition: transform 0.3s ease;
        }

        .modal-overlay.active .modal {
            transform: translateY(0);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid #444;
        }

        .modal-title {
            color: white;
            font-size: 1.125em;
            font-weight: 600;
        }

        .close-button {
            background: none;
            border: none;
            color: #999;
            font-size: 20px;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: color 0.2s;
        }

        .close-button:hover {
            color: white;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            display: block;
            color: white;
            font-size: 0.875em;
            font-weight: 500;
            margin-bottom: 6px;
        }

        .form-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #1a1a1a;
            color: white;
            font-size: 0.875em;
        }

        .form-input:focus {
            outline: none;
            border-color: #9146ff;
        }

        .form-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .form-checkbox input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #9146ff;
        }

        .form-actions {
            display: flex;
            gap: 12px;
            margin-top: 24px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            font-size: 0.875em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #9146ff;
            color: white;
        }

        .btn-primary:hover {
            background: #7a3fd8;
        }

        .btn-secondary {
            background: #444;
            color: white;
        }

        .btn-secondary:hover {
            background: #555;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .message.removing {
            animation: slideOut 0.3s ease forwards;
        }

        @keyframes slideOut {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(10px);
            }
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <div class="header-left">
                <span>Twitch Chat</span>
            </div>
            <div class="header-right">
                <span class="status" id="status">Connecting...</span>
                <button class="config-button" id="config-button" title="Settings">
                    <svg class="config-icon" viewBox="0 0 24 24">
                        <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.22,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.22,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.68 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z"/>
                    </svg>
                </button>
            </div>
        </div>
        <div class="chat-messages" id="chat-messages">
            <!-- Messages will appear here -->
        </div>
    </div>

    <!-- Configuration Modal -->
    <div class="modal-overlay" id="modal-overlay">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Chat Settings</h3>
                <button class="close-button" id="close-modal">&times;</button>
            </div>
            <form id="config-form">
                <div class="form-group">
                    <label class="form-label" for="max-messages">Max Messages</label>
                    <input type="number" id="max-messages" class="form-input" min="10" max="100" step="5">
                </div>
                <div class="form-group">
                    <label class="form-label" for="message-duration">Message Duration (seconds)</label>
                    <input type="number" id="message-duration" class="form-input" min="30" max="300" step="10">
                </div>
                <div class="form-group">
                    <div class="form-checkbox">
                        <input type="checkbox" id="enable-background">
                        <label class="form-label" for="enable-background">Enable Background</label>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-label" for="chat-scale">Scale: <span id="scale-value">1.0</span>x</label>
                    <input type="range" id="chat-scale" class="form-input" min="0.5" max="2" step="0.01" value="1">
                </div>
                <div class="form-actions">
                    <button type="button" class="btn btn-secondary" id="cancel-button">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        class SimpleTwitchChat {
            constructor() {
                // Configuration constants
                this.CONFIG = {
                    MAX_MESSAGES: 35,
                    MESSAGE_DURATION: 100000, // 100 seconds
                    DEFAULT_CHANNEL: 'takotoken',
                    TWITCH_IRC_URL: 'wss://irc-ws.chat.twitch.tv:443',
                    BADGE_API_URL: 'https://badges.twitch.tv/v1/badges',
                    USER_API_URL: 'https://api.ivr.fi/v2/twitch/user',
                    EMOTE_CDN_URL: 'https://static-cdn.jtvnw.net/emoticons/v2',
                    ENABLE_BACKGROUND: true,
                    SCALE: 1.0
                };

                // Twitch color palette
                this.TWITCH_COLORS = [
                    '#FF0000', '#0000FF', '#00FF00', '#B22222', '#FF7F50',
                    '#9ACD32', '#FF4500', '#2E8B57', '#DAA520', '#D2691E',
                    '#5F9EA0', '#1E90FF', '#FF69B4', '#8A2BE2', '#00FF7F',
                    '#FF6347', '#40E0D0', '#EE82EE', '#F5DEB3', '#FFFFFF',
                    '#F0E68C', '#DDA0DD', '#B0E0E6', '#FFB6C1', '#FFA07A',
                    '#20B2AA', '#87CEEB', '#778899', '#B0C4DE', '#FFFFE0'
                ];

                // Badge text mapping
                this.BADGE_TEXT_MAP = {
                    'moderator': 'MOD',
                    'subscriber': 'SUB',
                    'vip': 'VIP',
                    'broadcaster': 'BROADCASTER',
                    'founder': 'FOUNDER',
                    'staff': 'STAFF',
                    'admin': 'ADMIN',
                    'global_mod': 'GLOBAL MOD',
                    'premium': 'PREMIUM'
                };

                // Allowed badge types
                this.ALLOWED_BADGES = [
                    'vip', 'subscriber', 'moderator', 'broadcaster', 
                    'founder', 'staff', 'admin', 'global_mod', 'premium'
                ];

                // Instance properties
                this.messages = [];
                this.ws = null;
                this.channelName = this.getChannelFromURL();
                this.channelId = null;
                this.badgeCache = {};
                this.colorCache = new Map();
                this.lastBadgeVersions = {};

                this.init();
                this.initModal();
            }

            initModal() {
                const configButton = document.getElementById('config-button');
                const modalOverlay = document.getElementById('modal-overlay');
                const closeButton = document.getElementById('close-modal');
                const cancelButton = document.getElementById('cancel-button');
                const configForm = document.getElementById('config-form');
                const scaleInput = document.getElementById('chat-scale');
                const scaleValue = document.getElementById('scale-value');

                // Load current settings
                this.loadSettings();

                // Event listeners
                configButton.addEventListener('click', () => this.openModal());
                closeButton.addEventListener('click', () => this.closeModal());
                cancelButton.addEventListener('click', () => this.closeModal());
                modalOverlay.addEventListener('click', (e) => {
                    if (e.target === modalOverlay) this.closeModal();
                });
                configForm.addEventListener('submit', (e) => this.saveSettings(e));

                // Add scale slider event listener ONCE here
                if (scaleInput && scaleValue && !scaleInput._listenerAdded) {
                    scaleInput.addEventListener('input', (e) => {
                        const val = parseFloat(e.target.value);
                        scaleValue.textContent = val.toFixed(2);
                        this.previewScale(val);
                    });
                    scaleInput._listenerAdded = true;
                }

                // Close modal on Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && modalOverlay.classList.contains('active')) {
                        this.closeModal();
                    }
                    // Open config with Ctrl+, or Cmd+,
                    if ((e.ctrlKey || e.metaKey) && e.key === ',') {
                        // Don't trigger if focused on input/textarea
                        const active = document.activeElement;
                        if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) return;
                        e.preventDefault();
                        this.openModal();
                    }
                });
            }

            loadSettings() {
                const maxMessagesInput = document.getElementById('max-messages');
                const messageDurationInput = document.getElementById('message-duration');
                const enableBackgroundInput = document.getElementById('enable-background');
                const scaleInput = document.getElementById('chat-scale');
                const scaleValue = document.getElementById('scale-value');

                maxMessagesInput.value = this.CONFIG.MAX_MESSAGES;
                messageDurationInput.value = this.CONFIG.MESSAGE_DURATION / 1000; // Convert to seconds
                enableBackgroundInput.checked = this.CONFIG.ENABLE_BACKGROUND;
                scaleInput.value = this.CONFIG.SCALE;
                scaleValue.textContent = this.CONFIG.SCALE.toFixed(2);
                this.previewScale(parseFloat(this.CONFIG.SCALE));
            }

            openModal() {
                const modalOverlay = document.getElementById('modal-overlay');
                modalOverlay.classList.add('active');
            }

            closeModal() {
                const modalOverlay = document.getElementById('modal-overlay');
                modalOverlay.classList.remove('active');
            }

            saveSettings(e) {
                e.preventDefault();

                const maxMessages = parseInt(document.getElementById('max-messages').value);
                const messageDuration = parseInt(document.getElementById('message-duration').value) * 1000; // Convert to milliseconds
                const enableBackground = document.getElementById('enable-background').checked;
                const scale = parseFloat(document.getElementById('chat-scale').value);

                // Update configuration
                this.CONFIG.MAX_MESSAGES = maxMessages;
                this.CONFIG.MESSAGE_DURATION = messageDuration;
                this.CONFIG.ENABLE_BACKGROUND = enableBackground;
                this.CONFIG.SCALE = scale;

                // Apply background setting
                this.applyBackgroundSetting();
                this.applyScale();

                // Save to localStorage
                this.saveToLocalStorage();

                this.closeModal();
            }

            applyBackgroundSetting() {
                const chatContainer = document.querySelector('.chat-container');
                if (this.CONFIG.ENABLE_BACKGROUND) {
                    chatContainer.style.background = 'rgba(0, 0, 0, 0.7)';
                    chatContainer.style.backdropFilter = 'blur(5px)';
                } else {
                    chatContainer.style.background = 'transparent';
                    chatContainer.style.backdropFilter = 'none';
                }
            }

            saveToLocalStorage() {
                const settings = {
                    maxMessages: this.CONFIG.MAX_MESSAGES,
                    messageDuration: this.CONFIG.MESSAGE_DURATION,
                    enableBackground: this.CONFIG.ENABLE_BACKGROUND,
                    scale: this.CONFIG.SCALE
                };
                localStorage.setItem('twitchChatSettings', JSON.stringify(settings));
            }

            loadFromLocalStorage() {
                const saved = localStorage.getItem('twitchChatSettings');
                if (saved) {
                    try {
                        const settings = JSON.parse(saved);
                        this.CONFIG.MAX_MESSAGES = settings.maxMessages || this.CONFIG.MAX_MESSAGES;
                        this.CONFIG.MESSAGE_DURATION = settings.messageDuration || this.CONFIG.MESSAGE_DURATION;
                        this.CONFIG.ENABLE_BACKGROUND = settings.enableBackground !== undefined ? settings.enableBackground : this.CONFIG.ENABLE_BACKGROUND;
                        this.CONFIG.SCALE = settings.scale !== undefined ? settings.scale : this.CONFIG.SCALE;
                    } catch (error) {
                        console.warn('Failed to load settings from localStorage:', error);
                    }
                }
            }

            async init() {
                // Load saved settings first
                this.loadFromLocalStorage();
                
                try {
                    await this.fetchGlobalBadges();
                    await this.fetchChannelIdAndBadges();
                    this.connectToChat();
                    this.applyBackgroundSetting();
                    this.applyScale();
                } catch (error) {
                    console.error('Failed to initialize chat:', error);
                    this.updateStatus('Initialization failed');
                }
            }

            async fetchGlobalBadges() {
                try {
                    const response = await fetch(`${this.CONFIG.BADGE_API_URL}/global/display`);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    const data = await response.json();
                    this.badgeCache = data.badge_sets || {};
                } catch (error) {
                    console.warn('Failed to fetch global badges:', error);
                    this.badgeCache = {};
                }
            }

            async fetchChannelIdAndBadges() {
                try {
                    // Get channel ID from login name
                    const userResponse = await fetch(`${this.CONFIG.USER_API_URL}?login=${this.channelName}`);
                    if (!userResponse.ok) throw new Error(`HTTP ${userResponse.status}`);
                    
                    const userData = await userResponse.json();
                    if (!userData?.id) return;

                    this.channelId = userData.id;

                    // Fetch channel badges
                    const badgeResponse = await fetch(`${this.CONFIG.BADGE_API_URL}/channels/${this.channelId}/display`);
                    if (!badgeResponse.ok) throw new Error(`HTTP ${badgeResponse.status}`);
                    
                    const badgeData = await badgeResponse.json();
                    if (badgeData.badge_sets) {
                        this.mergeChannelBadges(badgeData.badge_sets);
                    }
                } catch (error) {
                    console.warn('Failed to fetch channel badges:', error);
                }
            }

            mergeChannelBadges(channelBadges) {
                for (const badgeType in channelBadges) {
                    if (!this.badgeCache[badgeType]) {
                        this.badgeCache[badgeType] = channelBadges[badgeType];
                    } else {
                        // Merge versions
                        this.badgeCache[badgeType].versions = {
                            ...this.badgeCache[badgeType].versions,
                            ...channelBadges[badgeType].versions
                        };
                    }
                }
            }

            getChannelFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                const channel = urlParams.get('channel') || this.CONFIG.DEFAULT_CHANNEL;
                return channel.toLowerCase();
            }

            generateTwitchColor(username) {
                // Check cache first
                if (this.colorCache.has(username)) {
                    return this.colorCache.get(username);
                }
                
                const name = username.toLowerCase();
                let hash = 0;
                
                // Generate hash from username
                for (let i = 0; i < name.length; i++) {
                    hash = ((hash << 5) - hash) + name.charCodeAt(i);
                    hash = hash & hash; // Convert to 32-bit integer
                }
                
                // Select color from palette
                const colorIndex = Math.abs(hash) % this.TWITCH_COLORS.length;
                let color = this.TWITCH_COLORS[colorIndex];
                
                // Add slight variation to reduce conflicts
                const adjustment = (hash >> 8) % 3;
                if (adjustment === 1) {
                    color = this.adjustColor(color, 10);
                } else if (adjustment === 2) {
                    color = this.adjustColor(color, -10);
                }
                
                this.colorCache.set(username, color);
                return color;
            }

            adjustColor(hexColor, adjustment) {
                const r = parseInt(hexColor.slice(1, 3), 16);
                const g = parseInt(hexColor.slice(3, 5), 16);
                const b = parseInt(hexColor.slice(5, 7), 16);
                
                const newR = Math.max(0, Math.min(255, r + adjustment));
                const newG = Math.max(0, Math.min(255, g + adjustment));
                const newB = Math.max(0, Math.min(255, b + adjustment));
                
                return this.rgbToHex(newR, newG, newB);
            }

            connectToChat() {
                try {
                    this.ws = new WebSocket(this.CONFIG.TWITCH_IRC_URL);
                    
                    this.ws.onopen = () => {
                        console.log('Connected to Twitch IRC');
                        this.authenticate();
                    };
                    
                    this.ws.onmessage = (event) => {
                        this.handleMessage(event.data);
                    };
                    
                    this.ws.onerror = (error) => {
                        console.warn('WebSocket error:', error);
                        this.updateStatus('Connection error');
                    };
                    
                    this.ws.onclose = () => {
                        console.log('Disconnected from Twitch IRC');
                        this.updateStatus('Disconnected');
                    };
                    
                } catch (error) {
                    console.error('Failed to connect:', error);
                    this.updateStatus('Connection failed');
                }
            }

            authenticate() {
                this.ws.send('CAP REQ :twitch.tv/membership twitch.tv/tags twitch.tv/commands');
                this.ws.send('NICK justinfan12345');
                this.ws.send(`JOIN #${this.channelName}`);
                this.updateStatus(`Connected to ${this.channelName}`);
            }

            handleMessage(data) {
                const lines = data.split('\r\n');
                
                lines.forEach(line => {
                    if (line.startsWith('PING')) {
                        this.ws.send('PONG :tmi.twitch.tv');
                        return;
                    }
                    
                    if (line.includes('PRIVMSG')) {
                        this.parseChatMessage(line);
                    }
                });
            }

            parseChatMessage(line) {
                const match = line.match(/@(.+?) PRIVMSG #\w+ :(.+)/);
                if (!match) return;

                const tags = this.parseTags(line);
                const username = tags['display-name'] || match[1].split('!')[0];
                const message = match[2];
                const color = this.parseColor(tags.color, username);
                const badges = this.parseBadges(tags.badges);
                const emotes = this.parseEmotes(tags.emotes, message);
                const isSubscriber = tags.subscriber === '1';
                const isModerator = tags.mod === '1';

                this.addMessage(username, message, badges, isSubscriber, isModerator, color, emotes);
            }

            parseColor(colorTag, username) {
                if (!colorTag || colorTag === '') {
                    return this.generateTwitchColor(username);
                }

                let color = colorTag;
                if (color.startsWith('#')) {
                    // Already in hex format
                } else if (color.includes(',')) {
                    // RGB format
                    const rgb = color.split(',').map(c => parseInt(c.trim()));
                    color = this.rgbToHex(rgb[0], rgb[1], rgb[2]);
                }

                this.colorCache.set(username, color);
                return color;
            }

            parseEmotes(emotesString, message) {
                if (!emotesString) return [];
                
                const emotes = [];
                const emoteList = emotesString.split('/');
                
                emoteList.forEach(emoteData => {
                    if (!emoteData) return;
                    
                    const [emoteId, positions] = emoteData.split(':');
                    if (!positions) return;
                    
                    const positionList = positions.split(',');
                    positionList.forEach(position => {
                        const [start, end] = position.split('-').map(p => parseInt(p));
                        const emoteName = message.substring(start, end + 1);
                        
                        emotes.push({
                            id: emoteId,
                            name: emoteName,
                            start: start,
                            end: end
                        });
                    });
                });
                
                // Sort emotes by position (right to left for proper replacement)
                emotes.sort((a, b) => b.start - a.start);
                
                return emotes;
            }

            rgbToHex(r, g, b) {
                r = Math.max(0, Math.min(255, Math.round(r)));
                g = Math.max(0, Math.min(255, Math.round(g)));
                b = Math.max(0, Math.min(255, Math.round(b)));
                
                const toHex = (n) => {
                    const hex = n.toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                };
                
                return "#" + toHex(r) + toHex(g) + toHex(b);
            }

            parseTags(line) {
                const tagsMatch = line.match(/@(.+?) /);
                if (!tagsMatch) return {};
                
                const tagsString = tagsMatch[1];
                const tags = {};
                
                tagsString.split(';').forEach(tag => {
                    const [key, value] = tag.split('=');
                    tags[key] = value;
                });
                
                return tags;
            }

            parseBadges(badgesString) {
                if (!badgesString) return [];
                
                const badges = [];
                const badgeVersions = {};
                const badgeList = badgesString.split(',');
                
                badgeList.forEach(badge => {
                    const [type, version] = badge.split('/');
                    badges.push(type);
                    badgeVersions[type] = version;
                });
                
                this.lastBadgeVersions = badgeVersions;
                return badges;
            }

            addMessage(username, message, badges = [], isSubscriber = false, isModerator = false, color = '#9146ff', emotes = []) {
                const messageObj = {
                    id: Date.now() + Math.random(),
                    username,
                    message,
                    badges,
                    isSubscriber,
                    isModerator,
                    color,
                    emotes,
                    badgeVersions: this.lastBadgeVersions,
                    timestamp: new Date()
                };

                this.messages.push(messageObj);
                this.renderMessage(messageObj);
                this.cleanupMessages();
                
                setTimeout(() => {
                    this.removeMessage(messageObj.id);
                }, this.CONFIG.MESSAGE_DURATION);
            }

            renderMessage(messageObj) {
                const messagesContainer = document.getElementById('chat-messages');
                const messageElement = document.createElement('div');
                messageElement.className = 'message';
                messageElement.dataset.messageId = messageObj.id;
                
                if (messageObj.isSubscriber) messageElement.classList.add('subscriber');
                if (messageObj.isModerator) messageElement.classList.add('moderator');

                // Create badges
                const badgesContainer = this.createBadgesContainer(messageObj);
                
                // Create username bubble
                const usernameSpan = this.createUsernameBubble(messageObj);
                
                // Create message text with emotes
                const messageTextSpan = document.createElement('span');
                messageTextSpan.className = 'message-text';
                this.appendMessageWithEmotes(messageTextSpan, messageObj.message, messageObj.emotes);

                // Assemble message
                messageElement.innerHTML = '';
                messageElement.appendChild(usernameSpan);
                messageElement.appendChild(badgesContainer);
                messageElement.appendChild(messageTextSpan);

                messagesContainer.appendChild(messageElement);

                // Ensure message is fully visible, even with emotes
                const emoteImages = messageElement.querySelectorAll('img.emote');
                if (emoteImages.length > 0) {
                    let loaded = 0;
                    emoteImages.forEach(img => {
                        img.onload = img.onerror = () => {
                            loaded++;
                            if (loaded === emoteImages.length) {
                                messageElement.scrollIntoView({ behavior: 'auto', block: 'end' });
                            }
                        };
                    });
                    // Fallback: scroll after a short delay in case some images never fire events
                    setTimeout(() => {
                        messageElement.scrollIntoView({ behavior: 'auto', block: 'end' });
                    }, 200);
                } else {
                    messageElement.scrollIntoView({ behavior: 'auto', block: 'end' });
                }
            }

            createBadgesContainer(messageObj) {
                const badgesContainer = document.createElement('span');
                badgesContainer.className = 'badges';
                
                messageObj.badges.forEach(badge => {
                    if (!this.ALLOWED_BADGES.includes(badge)) return;
                    
                    const badgeSpan = document.createElement('span');
                    badgeSpan.className = `badge ${badge}`;
                    badgeSpan.textContent = this.getBadgeText(badge);
                    badgesContainer.appendChild(badgeSpan);
                });
                
                return badgesContainer;
            }

            createUsernameBubble(messageObj) {
                const usernameSpan = document.createElement('span');
                usernameSpan.className = 'username username-bubble';
                
                const mainColor = messageObj.color;
                const darkerColor = this.getDarkerColor(mainColor);
                usernameSpan.style.background = `linear-gradient(90deg, ${mainColor}, ${darkerColor})`;
                usernameSpan.style.color = '#fff';
                usernameSpan.textContent = messageObj.username;
                
                return usernameSpan;
            }

            appendMessageWithEmotes(container, message, emotes) {
                if (!emotes || emotes.length === 0) {
                    container.textContent = message;
                    return;
                }
                
                // Sort emotes by start position
                emotes = [...emotes].sort((a, b) => a.start - b.start);
                let lastIndex = 0;
                
                for (let i = 0; i < emotes.length; i++) {
                    const emote = emotes[i];
                    
                    // Add text before emote
                    if (emote.start > lastIndex) {
                        const text = message.substring(lastIndex, emote.start);
                        container.appendChild(document.createTextNode(text));
                    }
                    
                    // Add emote image
                    const img = document.createElement('img');
                    img.src = `${this.CONFIG.EMOTE_CDN_URL}/${emote.id}/default/dark/1.0`;
                    img.alt = emote.name;
                    img.title = emote.name;
                    img.className = 'emote';
                    container.appendChild(img);
                    
                    lastIndex = emote.end + 1;
                }
                
                // Add remaining text
                if (lastIndex < message.length) {
                    container.appendChild(document.createTextNode(message.substring(lastIndex)));
                }
            }

            removeMessage(messageId) {
                const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
                if (messageElement) {
                    messageElement.classList.add('removing');
                    setTimeout(() => {
                        if (messageElement.parentNode) {
                            messageElement.parentNode.removeChild(messageElement);
                        }
                        this.messages = this.messages.filter(m => m.id !== messageId);
                    }, 300);
                }
            }

            cleanupMessages() {
                if (this.messages.length > this.CONFIG.MAX_MESSAGES) {
                    const messagesToRemove = this.messages.slice(0, this.messages.length - this.CONFIG.MAX_MESSAGES);
                    messagesToRemove.forEach(msg => this.removeMessage(msg.id));
                }
            }

            getBadgeText(type) {
                return this.BADGE_TEXT_MAP[type] || type.toUpperCase();
            }

            updateStatus(status) {
                const statusElement = document.getElementById('status');
                if (statusElement) {
                    statusElement.textContent = status;
                }
            }

            getDarkerColor(hex) {
                hex = hex.replace('#', '');
                let r = parseInt(hex.substring(0,2), 16);
                let g = parseInt(hex.substring(2,4), 16);
                let b = parseInt(hex.substring(4,6), 16);
                
                r = Math.round(r * 0.7);
                g = Math.round(g * 0.7);
                b = Math.round(b * 0.7);
                
                return this.rgbToHex(r, g, b);
            }

            previewScale(scale) {
                const chatContainer = document.querySelector('.chat-container');
                // Base font size is 16px, scale 1.0 = 16px, 2.0 = 32px, 0.5 = 8px
                const baseFontSize = 16;
                chatContainer.style.fontSize = (baseFontSize * parseFloat(scale)) + 'px';
            }

            applyScale() {
                this.previewScale(this.CONFIG.SCALE);
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new SimpleTwitchChat();
        });
    </script>
</body>
</html> 