<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Twitch Chat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: transparent;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        .chat-container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            border-radius: 8px;
            overflow: hidden;
        }

        .chat-header {
            background: linear-gradient(90deg, #9146ff, #bf46ff);
            padding: 8px 16px;
            color: white;
            font-weight: 600;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .chat-messages {
            flex: 1;
            padding: 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 6px;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        .chat-messages::-webkit-scrollbar {
            display: none;
        }

        .message {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0px;
            border-left: 2px dotted #b6b6b6;
            animation: slideIn 0.3s ease;
            color: white;
            font-size: 13px;
            line-height: 1.3;
        }

        .message.subscriber {
            border-left-color: #9146ff;
            background: rgba(255, 107, 107, 0.15);
        }

        .message.moderator {
            border-left-color: #00ff00;
            background: rgba(0, 255, 0, 0.15);
        }

        .username {
            font-weight: 600;
            margin-right: 8px;
        }

        .message-text {
            color: rgba(255, 255, 255, 0.9);
        }

        .emote {
            height: 1.2em;
            width: auto;
            vertical-align: middle;
            margin: 0 1px;
            display: inline-block;
        }

        .badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            margin-right: 6px;
        }

        .badge.subscriber {
            background: #9146ff;
            color: white;
        }

        .badge.moderator {
            background: #00ff00;
            color: black;
        }

        .badge.vip {
            background: #ffd700;
            color: black;
        }

        .status {
            font-size: 12px;
            opacity: 0.8;
        }

        .username-bubble {
            display: inline-block;
            padding: 2px 10px;
            border-radius: 16px;
            font-weight: 600;
            color: #fff !important;
            background: linear-gradient(90deg, #9146ff, #bf46ff);
            margin-right: 8px;
            box-shadow: 0 1px 4px 0 rgba(0,0,0,0.10);
            font-size: 13px;
            letter-spacing: 0.01em;
            transition: background 0.2s;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .message.removing {
            animation: slideOut 0.3s ease forwards;
        }

        @keyframes slideOut {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(10px);
            }
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <span>Twitch Chat</span>
            <span class="status" id="status">Connecting...</span>
        </div>
        <div class="chat-messages" id="chat-messages">
            <!-- Messages will appear here -->
        </div>
    </div>

    <script>
        class SimpleTwitchChat {
            constructor() {
                // Configuration constants
                this.CONFIG = {
                    MAX_MESSAGES: 35,
                    MESSAGE_DURATION: 100000, // 100 seconds
                    DEFAULT_CHANNEL: 'takotoken',
                    TWITCH_IRC_URL: 'wss://irc-ws.chat.twitch.tv:443',
                    BADGE_API_URL: 'https://badges.twitch.tv/v1/badges',
                    USER_API_URL: 'https://api.ivr.fi/v2/twitch/user',
                    EMOTE_CDN_URL: 'https://static-cdn.jtvnw.net/emoticons/v2'
                };

                // Twitch color palette
                this.TWITCH_COLORS = [
                    '#FF0000', '#0000FF', '#00FF00', '#B22222', '#FF7F50',
                    '#9ACD32', '#FF4500', '#2E8B57', '#DAA520', '#D2691E',
                    '#5F9EA0', '#1E90FF', '#FF69B4', '#8A2BE2', '#00FF7F',
                    '#FF6347', '#40E0D0', '#EE82EE', '#F5DEB3', '#FFFFFF',
                    '#F0E68C', '#DDA0DD', '#B0E0E6', '#FFB6C1', '#FFA07A',
                    '#20B2AA', '#87CEEB', '#778899', '#B0C4DE', '#FFFFE0'
                ];

                // Badge text mapping
                this.BADGE_TEXT_MAP = {
                    'moderator': 'MOD',
                    'subscriber': 'SUB',
                    'vip': 'VIP',
                    'broadcaster': 'BROADCASTER',
                    'founder': 'FOUNDER',
                    'staff': 'STAFF',
                    'admin': 'ADMIN',
                    'global_mod': 'GLOBAL MOD',
                    'premium': 'PREMIUM'
                };

                // Allowed badge types
                this.ALLOWED_BADGES = [
                    'vip', 'subscriber', 'moderator', 'broadcaster', 
                    'founder', 'staff', 'admin', 'global_mod', 'premium'
                ];

                // Instance properties
                this.messages = [];
                this.ws = null;
                this.channelName = this.getChannelFromURL();
                this.channelId = null;
                this.badgeCache = {};
                this.colorCache = new Map();
                this.lastBadgeVersions = {};

                this.init();
            }

            async init() {
                try {
                    await this.fetchGlobalBadges();
                    await this.fetchChannelIdAndBadges();
                    this.connectToChat();
                } catch (error) {
                    console.error('Failed to initialize chat:', error);
                    this.updateStatus('Initialization failed');
                }
            }

            async fetchGlobalBadges() {
                try {
                    const response = await fetch(`${this.CONFIG.BADGE_API_URL}/global/display`);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    
                    const data = await response.json();
                    this.badgeCache = data.badge_sets || {};
                } catch (error) {
                    console.warn('Failed to fetch global badges:', error);
                    this.badgeCache = {};
                }
            }

            async fetchChannelIdAndBadges() {
                try {
                    // Get channel ID from login name
                    const userResponse = await fetch(`${this.CONFIG.USER_API_URL}?login=${this.channelName}`);
                    if (!userResponse.ok) throw new Error(`HTTP ${userResponse.status}`);
                    
                    const userData = await userResponse.json();
                    if (!userData?.id) return;

                    this.channelId = userData.id;

                    // Fetch channel badges
                    const badgeResponse = await fetch(`${this.CONFIG.BADGE_API_URL}/channels/${this.channelId}/display`);
                    if (!badgeResponse.ok) throw new Error(`HTTP ${badgeResponse.status}`);
                    
                    const badgeData = await badgeResponse.json();
                    if (badgeData.badge_sets) {
                        this.mergeChannelBadges(badgeData.badge_sets);
                    }
                } catch (error) {
                    console.warn('Failed to fetch channel badges:', error);
                }
            }

            mergeChannelBadges(channelBadges) {
                for (const badgeType in channelBadges) {
                    if (!this.badgeCache[badgeType]) {
                        this.badgeCache[badgeType] = channelBadges[badgeType];
                    } else {
                        // Merge versions
                        this.badgeCache[badgeType].versions = {
                            ...this.badgeCache[badgeType].versions,
                            ...channelBadges[badgeType].versions
                        };
                    }
                }
            }

            getChannelFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                const channel = urlParams.get('channel') || this.CONFIG.DEFAULT_CHANNEL;
                return channel.toLowerCase();
            }

            generateTwitchColor(username) {
                // Check cache first
                if (this.colorCache.has(username)) {
                    return this.colorCache.get(username);
                }
                
                const name = username.toLowerCase();
                let hash = 0;
                
                // Generate hash from username
                for (let i = 0; i < name.length; i++) {
                    hash = ((hash << 5) - hash) + name.charCodeAt(i);
                    hash = hash & hash; // Convert to 32-bit integer
                }
                
                // Select color from palette
                const colorIndex = Math.abs(hash) % this.TWITCH_COLORS.length;
                let color = this.TWITCH_COLORS[colorIndex];
                
                // Add slight variation to reduce conflicts
                const adjustment = (hash >> 8) % 3;
                if (adjustment === 1) {
                    color = this.adjustColor(color, 10);
                } else if (adjustment === 2) {
                    color = this.adjustColor(color, -10);
                }
                
                this.colorCache.set(username, color);
                return color;
            }

            adjustColor(hexColor, adjustment) {
                const r = parseInt(hexColor.slice(1, 3), 16);
                const g = parseInt(hexColor.slice(3, 5), 16);
                const b = parseInt(hexColor.slice(5, 7), 16);
                
                const newR = Math.max(0, Math.min(255, r + adjustment));
                const newG = Math.max(0, Math.min(255, g + adjustment));
                const newB = Math.max(0, Math.min(255, b + adjustment));
                
                return this.rgbToHex(newR, newG, newB);
            }

            connectToChat() {
                try {
                    this.ws = new WebSocket(this.CONFIG.TWITCH_IRC_URL);
                    
                    this.ws.onopen = () => {
                        console.log('Connected to Twitch IRC');
                        this.authenticate();
                    };
                    
                    this.ws.onmessage = (event) => {
                        this.handleMessage(event.data);
                    };
                    
                    this.ws.onerror = (error) => {
                        console.warn('WebSocket error:', error);
                        this.updateStatus('Connection error');
                    };
                    
                    this.ws.onclose = () => {
                        console.log('Disconnected from Twitch IRC');
                        this.updateStatus('Disconnected');
                    };
                    
                } catch (error) {
                    console.error('Failed to connect:', error);
                    this.updateStatus('Connection failed');
                }
            }

            authenticate() {
                this.ws.send('CAP REQ :twitch.tv/membership twitch.tv/tags twitch.tv/commands');
                this.ws.send('NICK justinfan12345');
                this.ws.send(`JOIN #${this.channelName}`);
                this.updateStatus(`Connected to ${this.channelName}`);
            }

            handleMessage(data) {
                const lines = data.split('\r\n');
                
                lines.forEach(line => {
                    if (line.startsWith('PING')) {
                        this.ws.send('PONG :tmi.twitch.tv');
                        return;
                    }
                    
                    if (line.includes('PRIVMSG')) {
                        this.parseChatMessage(line);
                    }
                });
            }

            parseChatMessage(line) {
                const match = line.match(/@(.+?) PRIVMSG #\w+ :(.+)/);
                if (!match) return;

                const tags = this.parseTags(line);
                const username = tags['display-name'] || match[1].split('!')[0];
                const message = match[2];
                const color = this.parseColor(tags.color, username);
                const badges = this.parseBadges(tags.badges);
                const emotes = this.parseEmotes(tags.emotes, message);
                const isSubscriber = tags.subscriber === '1';
                const isModerator = tags.mod === '1';

                this.addMessage(username, message, badges, isSubscriber, isModerator, color, emotes);
            }

            parseColor(colorTag, username) {
                if (!colorTag || colorTag === '') {
                    return this.generateTwitchColor(username);
                }

                let color = colorTag;
                if (color.startsWith('#')) {
                    // Already in hex format
                } else if (color.includes(',')) {
                    // RGB format
                    const rgb = color.split(',').map(c => parseInt(c.trim()));
                    color = this.rgbToHex(rgb[0], rgb[1], rgb[2]);
                }

                this.colorCache.set(username, color);
                return color;
            }

            parseEmotes(emotesString, message) {
                if (!emotesString) return [];
                
                const emotes = [];
                const emoteList = emotesString.split('/');
                
                emoteList.forEach(emoteData => {
                    if (!emoteData) return;
                    
                    const [emoteId, positions] = emoteData.split(':');
                    if (!positions) return;
                    
                    const positionList = positions.split(',');
                    positionList.forEach(position => {
                        const [start, end] = position.split('-').map(p => parseInt(p));
                        const emoteName = message.substring(start, end + 1);
                        
                        emotes.push({
                            id: emoteId,
                            name: emoteName,
                            start: start,
                            end: end
                        });
                    });
                });
                
                // Sort emotes by position (right to left for proper replacement)
                emotes.sort((a, b) => b.start - a.start);
                
                return emotes;
            }

            rgbToHex(r, g, b) {
                r = Math.max(0, Math.min(255, Math.round(r)));
                g = Math.max(0, Math.min(255, Math.round(g)));
                b = Math.max(0, Math.min(255, Math.round(b)));
                
                const toHex = (n) => {
                    const hex = n.toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                };
                
                return "#" + toHex(r) + toHex(g) + toHex(b);
            }

            parseTags(line) {
                const tagsMatch = line.match(/@(.+?) /);
                if (!tagsMatch) return {};
                
                const tagsString = tagsMatch[1];
                const tags = {};
                
                tagsString.split(';').forEach(tag => {
                    const [key, value] = tag.split('=');
                    tags[key] = value;
                });
                
                return tags;
            }

            parseBadges(badgesString) {
                if (!badgesString) return [];
                
                const badges = [];
                const badgeVersions = {};
                const badgeList = badgesString.split(',');
                
                badgeList.forEach(badge => {
                    const [type, version] = badge.split('/');
                    badges.push(type);
                    badgeVersions[type] = version;
                });
                
                this.lastBadgeVersions = badgeVersions;
                return badges;
            }

            addMessage(username, message, badges = [], isSubscriber = false, isModerator = false, color = '#9146ff', emotes = []) {
                const messageObj = {
                    id: Date.now() + Math.random(),
                    username,
                    message,
                    badges,
                    isSubscriber,
                    isModerator,
                    color,
                    emotes,
                    badgeVersions: this.lastBadgeVersions,
                    timestamp: new Date()
                };

                this.messages.push(messageObj);
                this.renderMessage(messageObj);
                this.cleanupMessages();
                
                setTimeout(() => {
                    this.removeMessage(messageObj.id);
                }, this.CONFIG.MESSAGE_DURATION);
            }

            renderMessage(messageObj) {
                const messagesContainer = document.getElementById('chat-messages');
                const messageElement = document.createElement('div');
                messageElement.className = 'message';
                messageElement.dataset.messageId = messageObj.id;
                
                if (messageObj.isSubscriber) messageElement.classList.add('subscriber');
                if (messageObj.isModerator) messageElement.classList.add('moderator');

                // Create badges
                const badgesContainer = this.createBadgesContainer(messageObj);
                
                // Create username bubble
                const usernameSpan = this.createUsernameBubble(messageObj);
                
                // Create message text with emotes
                const messageTextSpan = document.createElement('span');
                messageTextSpan.className = 'message-text';
                this.appendMessageWithEmotes(messageTextSpan, messageObj.message, messageObj.emotes);

                // Assemble message
                messageElement.innerHTML = '';
                messageElement.appendChild(usernameSpan);
                messageElement.appendChild(badgesContainer);
                messageElement.appendChild(messageTextSpan);

                messagesContainer.appendChild(messageElement);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            createBadgesContainer(messageObj) {
                const badgesContainer = document.createElement('span');
                badgesContainer.className = 'badges';
                
                messageObj.badges.forEach(badge => {
                    if (!this.ALLOWED_BADGES.includes(badge)) return;
                    
                    const badgeSpan = document.createElement('span');
                    badgeSpan.className = `badge ${badge}`;
                    badgeSpan.textContent = this.getBadgeText(badge);
                    badgesContainer.appendChild(badgeSpan);
                });
                
                return badgesContainer;
            }

            createUsernameBubble(messageObj) {
                const usernameSpan = document.createElement('span');
                usernameSpan.className = 'username username-bubble';
                
                const mainColor = messageObj.color;
                const darkerColor = this.getDarkerColor(mainColor);
                usernameSpan.style.background = `linear-gradient(90deg, ${mainColor}, ${darkerColor})`;
                usernameSpan.style.color = '#fff';
                usernameSpan.textContent = messageObj.username;
                
                return usernameSpan;
            }

            appendMessageWithEmotes(container, message, emotes) {
                if (!emotes || emotes.length === 0) {
                    container.textContent = message;
                    return;
                }
                
                // Sort emotes by start position
                emotes = [...emotes].sort((a, b) => a.start - b.start);
                let lastIndex = 0;
                
                for (let i = 0; i < emotes.length; i++) {
                    const emote = emotes[i];
                    
                    // Add text before emote
                    if (emote.start > lastIndex) {
                        const text = message.substring(lastIndex, emote.start);
                        container.appendChild(document.createTextNode(text));
                    }
                    
                    // Add emote image
                    const img = document.createElement('img');
                    img.src = `${this.CONFIG.EMOTE_CDN_URL}/${emote.id}/default/dark/1.0`;
                    img.alt = emote.name;
                    img.title = emote.name;
                    img.className = 'emote';
                    container.appendChild(img);
                    
                    lastIndex = emote.end + 1;
                }
                
                // Add remaining text
                if (lastIndex < message.length) {
                    container.appendChild(document.createTextNode(message.substring(lastIndex)));
                }
            }

            removeMessage(messageId) {
                const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
                if (messageElement) {
                    messageElement.classList.add('removing');
                    setTimeout(() => {
                        if (messageElement.parentNode) {
                            messageElement.parentNode.removeChild(messageElement);
                        }
                        this.messages = this.messages.filter(m => m.id !== messageId);
                    }, 300);
                }
            }

            cleanupMessages() {
                if (this.messages.length > this.CONFIG.MAX_MESSAGES) {
                    const messagesToRemove = this.messages.slice(0, this.messages.length - this.CONFIG.MAX_MESSAGES);
                    messagesToRemove.forEach(msg => this.removeMessage(msg.id));
                }
            }

            getBadgeText(type) {
                return this.BADGE_TEXT_MAP[type] || type.toUpperCase();
            }

            updateStatus(status) {
                const statusElement = document.getElementById('status');
                if (statusElement) {
                    statusElement.textContent = status;
                }
            }

            getDarkerColor(hex) {
                hex = hex.replace('#', '');
                let r = parseInt(hex.substring(0,2), 16);
                let g = parseInt(hex.substring(2,4), 16);
                let b = parseInt(hex.substring(4,6), 16);
                
                r = Math.round(r * 0.7);
                g = Math.round(g * 0.7);
                b = Math.round(b * 0.7);
                
                return this.rgbToHex(r, g, b);
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new SimpleTwitchChat();
        });
    </script>
</body>
</html> 